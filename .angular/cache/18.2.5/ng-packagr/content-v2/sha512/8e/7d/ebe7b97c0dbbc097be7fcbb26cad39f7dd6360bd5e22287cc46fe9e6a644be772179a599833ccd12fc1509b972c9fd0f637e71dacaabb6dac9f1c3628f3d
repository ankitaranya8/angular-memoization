{"hash":"939469fabcd580f4bba877ec83b0b59803a84a2f","fesm2022":[{"exports":["MemoService","MemoUtils","Memoize"],"facadeModuleId":"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/angular-function-cache.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo-utils.mjs","/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo.decorator.mjs","/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo.service.mjs","/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/public-api.mjs","/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/angular-function-cache.mjs"],"name":"angular-function-cache","type":"chunk","dynamicImports":[],"fileName":"angular-function-cache.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","Injectable"]},"imports":["@angular/core"],"modules":{"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo-utils.mjs":{"code":"class MemoUtils {\n    static cache = new Map();\n    static memoize(fn, resolver) {\n        return (...args) => {\n            const key = resolver ? resolver(...args) : JSON.stringify(args);\n            if (this.cache.has(key)) {\n                return this.cache.get(key);\n            }\n            const result = fn(...args);\n            this.cache.set(key, result);\n            return result;\n        };\n    }\n    static clearCache() {\n        this.cache.clear();\n    }\n}","originalLength":2323,"removedExports":[],"renderedExports":["MemoUtils"],"renderedLength":473},"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo.decorator.mjs":{"code":"function Memoize(resolver) {\n    return function (target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        const cache = new Map();\n        descriptor.value = function (...args) {\n            const key = resolver ? resolver(...args) : JSON.stringify(args);\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            const result = originalMethod.apply(this, args);\n            cache.set(key, result);\n            return result;\n        };\n        return descriptor;\n    };\n}","originalLength":2559,"removedExports":[],"renderedExports":["Memoize"],"renderedLength":549},"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/lib/memo.service.mjs":{"code":"class MemoService {\n    clearCache() {\n        MemoUtils.clearCache();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });","originalLength":1665,"removedExports":[],"renderedExports":["MemoService"],"renderedLength":632},"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of angular-cache\n */","originalLength":744,"removedExports":[],"renderedExports":[],"renderedLength":45},"/Users/ankitaranya/Documents/GitHub/angular-memoization/dist/angular-cache/esm2022/angular-function-cache.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":532,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\nclass MemoUtils {\n    static cache = new Map();\n    static memoize(fn, resolver) {\n        return (...args) => {\n            const key = resolver ? resolver(...args) : JSON.stringify(args);\n            if (this.cache.has(key)) {\n                return this.cache.get(key);\n            }\n            const result = fn(...args);\n            this.cache.set(key, result);\n            return result;\n        };\n    }\n    static clearCache() {\n        this.cache.clear();\n    }\n}\n\nfunction Memoize(resolver) {\n    return function (target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        const cache = new Map();\n        descriptor.value = function (...args) {\n            const key = resolver ? resolver(...args) : JSON.stringify(args);\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            const result = originalMethod.apply(this, args);\n            cache.set(key, result);\n            return result;\n        };\n        return descriptor;\n    };\n}\n\nclass MemoService {\n    clearCache() {\n        MemoUtils.clearCache();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: MemoService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-cache\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MemoService, MemoUtils, Memoize };\n//# sourceMappingURL=angular-function-cache.mjs.map\n","map":null,"preliminaryFileName":"angular-function-cache.mjs","sourcemapFileName":"angular-function-cache.mjs.map"},{"fileName":"angular-function-cache.mjs.map","needsCodeReference":false,"originalFileName":null,"source":"{\"version\":3,\"file\":\"angular-function-cache.mjs\",\"sources\":[\"../../../projects/angular-cache/src/lib/memo-utils.ts\",\"../../../projects/angular-cache/src/lib/memo.decorator.ts\",\"../../../projects/angular-cache/src/lib/memo.service.ts\",\"../../../projects/angular-cache/src/public-api.ts\",\"../../../projects/angular-cache/src/angular-function-cache.ts\"],\"sourcesContent\":[\"export class MemoUtils {\\n    private static cache = new Map<string, any>();\\n  \\n    static memoize(fn: Function, resolver?: (...args: any[]) => string): Function {\\n      return (...args: any[]): any => {\\n        const key = resolver ? resolver(...args) : JSON.stringify(args);\\n        if (this.cache.has(key)) {\\n          return this.cache.get(key);\\n        }\\n        const result = fn(...args);\\n        this.cache.set(key, result);\\n        return result;\\n      };\\n    }\\n  \\n    static clearCache() {\\n      this.cache.clear();\\n    }\\n  }\\n  \",\"export function Memoize(resolver?: (...args: any[]) => string): MethodDecorator {\\n    return function (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\\n      const originalMethod = descriptor.value;\\n      const cache = new Map<string, any>();\\n  \\n      descriptor.value = function (...args: any[]) {\\n        const key = resolver ? resolver(...args) : JSON.stringify(args);\\n        if (cache.has(key)) {\\n          return cache.get(key);\\n        }\\n        const result = originalMethod.apply(this, args);\\n        cache.set(key, result);\\n        return result;\\n      };\\n  \\n      return descriptor;\\n    };\\n  }\\n  \",\"import { Injectable } from '@angular/core';\\nimport { MemoUtils } from './memo-utils';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class MemoService {\\n  clearCache(): void {\\n    MemoUtils.clearCache();\\n  }\\n}\\n\",\"/*\\n * Public API Surface of angular-cache\\n */\\n\\nexport * from './lib/memo-utils';\\nexport * from './lib/memo.decorator';\\nexport * from './lib/memo.service';\\n\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\";;;MAAa,SAAS,CAAA;AACV,IAAA,OAAO,KAAK,GAAG,IAAI,GAAG,EAAe,CAAC;AAE9C,IAAA,OAAO,OAAO,CAAC,EAAY,EAAE,QAAqC,EAAA;AAChE,QAAA,OAAO,CAAC,GAAG,IAAW,KAAS;YAC7B,MAAM,GAAG,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAChE,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACvB,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aAC5B;AACD,YAAA,MAAM,MAAM,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YAC3B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAC5B,YAAA,OAAO,MAAM,CAAC;AAChB,SAAC,CAAC;KACH;AAED,IAAA,OAAO,UAAU,GAAA;AACf,QAAA,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;KACpB;;;ACjBC,SAAU,OAAO,CAAC,QAAqC,EAAA;AACzD,IAAA,OAAO,UAAU,MAAc,EAAE,WAA4B,EAAE,UAAwC,EAAA;AACrG,QAAA,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;AACxC,QAAA,MAAM,KAAK,GAAG,IAAI,GAAG,EAAe,CAAC;AAErC,QAAA,UAAU,CAAC,KAAK,GAAG,UAAU,GAAG,IAAW,EAAA;YACzC,MAAM,GAAG,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AAChE,YAAA,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAClB,gBAAA,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aACvB;YACD,MAAM,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAChD,YAAA,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AACvB,YAAA,OAAO,MAAM,CAAC;AAChB,SAAC,CAAC;AAEF,QAAA,OAAO,UAAU,CAAC;AACpB,KAAC,CAAC;AACJ;;MCXW,WAAW,CAAA;IACtB,UAAU,GAAA;QACR,SAAS,CAAC,UAAU,EAAE,CAAC;KACxB;uGAHU,WAAW,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAX,IAAA,OAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,WAAW,cAFV,MAAM,EAAA,CAAA,CAAA;;2FAEP,WAAW,EAAA,UAAA,EAAA,CAAA;kBAHvB,UAAU;AAAC,YAAA,IAAA,EAAA,CAAA;AACV,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA,CAAA;;;ACLD;;AAEG;;ACFH;;AAEG;;;;\"}","type":"asset"}]}